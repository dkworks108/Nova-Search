<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nova Search - Cinematic AI Assistant</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Using Tabler Icons via CSS.gg for simplicity -->
    <link href="https://css.gg/css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">

    <!-- Custom Styles -->
    <style>
        :root {
            --bg-color: #0D0D0D;
            --text-color: #FFFFFF;
            --accent-color: #00FFFF; /* Neon Cyan */
            --accent-color-rgb: 0, 255, 255;
            --gold-color: #FFD700;
            --gold-color-rgb: 255, 215, 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Important for full-screen canvas */
        }

        /* ðŸ”¹ Scroll Snapping Container */
        .scroll-container {
            scroll-snap-type: y mandatory;
            overflow-y: scroll;
            height: 100vh;
        }

        .scroll-section {
            scroll-snap-align: start;
            height: 100vh;
            width: 100vw;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .font-playfair {
            font-family: 'Playfair Display', serif;
        }

        /* ðŸ”¹ Header Styling */
        #header {
            background-color: rgba(13, 13, 13, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .icon-glow:hover {
            color: var(--accent-color);
            /* Tailwind's drop-shadow doesn't support color variables well, so we use filter */
            filter: drop-shadow(0 0 6px var(--accent-color));
        }

        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }

        .search-bar {
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        .search-bar:focus-within {
            border-color: var(--accent-color);
            box-shadow: 0 0 15px rgba(var(--accent-color-rgb), 0.3);
        }
        
    </style>
</head>
<body class="antialiased">

    <!-- ðŸ”¹ Section A: Header Start -->
    <header id="header" class="sticky top-0 z-50 w-full">
        <div class="container mx-auto px-6 py-4 flex justify-between items-center">
            <div class="font-playfair text-2xl font-bold tracking-wider text-white">
                Nova Search
            </div>
            <nav class="hidden md:flex items-center space-x-10">
                <a href="#hero" class="flex items-center space-x-2 text-gray-300 transition-all duration-300 icon-glow">
                    <i class="gg-info"></i>
                    <span>About</span>
                </a>
                <a href="#interactive-section" class="flex items-center space-x-2 text-gray-300 transition-all duration-300 icon-glow">
                    <i class="gg-terminal"></i>
                    <span>Interface</span>
                </a>
                <a href="#footer" class="flex items-center space-x-2 text-gray-300 transition-all duration-300 icon-glow">
                    <i class="gg-profile"></i>
                    <span>Profile</span>
                </a>
            </nav>
            <button class="md:hidden text-white">
                <i class="gg-menu"></i>
            </button>
        </div>
    </header>
    <!-- ðŸ”¹ Section A: Header End -->

    <div class="scroll-container" style="margin-top: -72px;"> <!-- Offset for sticky header height -->
        <!-- ðŸ”¹ Section B: Hero Section Starts -->
        <section id="hero" class="scroll-section text-center">
            <div class="relative z-10 p-6">
                <h1 class="text-5xl md:text-7xl lg:text-8xl font-playfair font-bold text-white hero-glow tracking-wider">
                    Discover the Power of Precision
                </h1>
                <p class="mt-6 text-lg md:text-xl text-gray-300 max-w-2xl mx-auto tracking-widest">
                    Search Redefined with AI Elegance
                </p>
            </div>
        </section>
        <!-- ðŸ”¹ Section B: Hero Section Ends -->

        <!-- ðŸ”¹ Section C: Interactive Animation + Search Starts -->
        <section id="interactive-section" class="scroll-section bg-black/20">
            <div class="text-center z-10 mb-auto mt-24 px-4">
                <h2 class="text-3xl md:text-4xl font-bold mb-2">The Nova Assistant</h2>
                <p class="text-gray-400">The assistant is active. Trigger a search to interact.</p>
            </div>
            <!-- This canvas will hold the particle animation -->
            <canvas id="particle-canvas"></canvas>
            <div class="relative z-10 mt-auto mb-16 w-full max-w-2xl px-4">
                <div class="relative search-bar rounded-full bg-black/50">
                    <input type="text" placeholder="Ask anything..." class="w-full bg-transparent text-white placeholder-gray-500 py-4 px-6 rounded-full focus:outline-none">
                    <button id="search-trigger" class="absolute right-2 top-1/2 -translate-y-1/2 bg-[var(--accent-color)] text-black rounded-full p-2.5 hover:opacity-80 transition-opacity">
                        <i class="gg-arrow-right"></i>
                    </button>
                </div>
            </div>
        </section>
        <!-- ðŸ”¹ Section C: Interactive Animation + Search Ends -->

        <!-- ðŸ”¹ Section D: Footer Starts -->
        <footer id="footer" class="scroll-section bg-black">
            <div class="container mx-auto px-6 text-center max-w-4xl">
                <h3 class="text-4xl font-playfair font-bold text-white mb-6">Explore the Future with Nova</h3>
                <p class="text-gray-400 mb-12 leading-relaxed">
                    Nova Search is more than a tool; it's a paradigm shift. Our mission is to harness the power of advanced artificial intelligence to provide unparalleled precision and insight, transforming complex data into clear, actionable knowledge. We are crafting the future of information discovery.
                </p>
                <div class="flex justify-center space-x-8 mb-12">
                     <a href="#" class="text-gray-400 social-icon transition-all duration-300 icon-glow"><i class="gg-twitter" style="--ggs:1.5"></i></a>
                    <a href="#" class="text-gray-400 social-icon transition-all duration-300 icon-glow"><i class="gg-youtube" style="--ggs:1.5"></i></a>
                    <a href="#" class="text-gray-400 social-icon transition-all duration-300 icon-glow"><i class="gg-voicemail" style="--ggs:1.5"></i></a>
                </div>
                <p class="text-gray-600 text-sm">&copy; 2025 Nova Search. Crafted for the future.</p>
            </div>
        </footer>
        <!-- ðŸ”¹ Section D: Footer Ends -->
    </div>

    <!-- Libraries -->
    <script type="module">
        // Import necessary Three.js modules
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.2/build/three.module.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.128.2/examples/jsm/loaders/GLTFLoader.js';
        import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.11.5/index.js';

        // ðŸ”¹ --- Shader Definitions --- ðŸ”¹
        const vertexShader = `
            uniform float uTime;
            uniform float uState; // 0: running, 1: sensing, 2: relaxing
            uniform float uRunProgress; // 0 to 1 for running animation
            attribute float aIsHorn;
            attribute float aIsEye;
            attribute vec3 aNormal;

            varying float vIsHorn;
            varying float vIsEye;

            // Perlin noise functions
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            void main() {
                vIsHorn = aIsHorn;
                vIsEye = aIsEye;
                vec3 pos = position;

                // Running state
                float trailFactor = smoothstep(0.0, 0.5, uRunProgress) - smoothstep(0.5, 1.0, uRunProgress);
                float disintegration = snoise(pos * 3.0 + uTime * 2.0) * 0.2 * trailFactor;
                pos.x -= disintegration;

                // Sensing state
                float pulse = snoise(pos + uTime) * 0.1 * (1.0 - uState);
                if (uState == 1.0) { // sensing
                    pulse = snoise(pos * 2.0 + uTime * 3.0) * 0.05;
                }
                pos += aNormal * pulse;

                // Relaxing state
                if (uState == 2.0) {
                    float gentlePulse = sin(pos.y * 5.0 + uTime) * 0.02;
                    pos += aNormal * gentlePulse;
                }

                vec4 modelPosition = modelMatrix * vec4(pos, 1.0);
                vec4 viewPosition = viewMatrix * modelPosition;
                vec4 projectedPosition = projectionMatrix * viewPosition;

                gl_Position = projectedPosition;
                gl_PointSize = (aIsHorn > 0.5 ? 2.5 : 1.5) * (1.0 / -viewPosition.z);
            }
        `;

        const fragmentShader = `
            uniform float uTime;
            uniform float uState;
            varying float vIsHorn;
            varying float vIsEye;

            void main() {
                float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
                float strength = 1.0 - (distanceToCenter * 2.0);
                if (strength < 0.0) discard;

                vec3 color = vec3(0.0, 0.8, 0.8); // Darker Cyan for body

                if (vIsHorn > 0.5) {
                    float hornGlow = 0.0;
                    if(uState == 1.0) { // Sensing
                        hornGlow = 0.5 + (sin(uTime * 10.0) * 0.5 + 0.5) * 2.0;
                    }
                     if(uState == 2.0) { // Relaxing
                        hornGlow = 0.2 + (sin(uTime) * 0.5 + 0.5) * 0.2;
                    }
                    color = mix(color, vec3(1.0), hornGlow); // Mix with white for glow
                }

                if (vIsEye > 0.5 && uState == 1.0) {
                    color = vec3(1.0, 0.1, 0.1); // Red glow for eyes in sensing state
                }
                
                gl_FragColor = vec4(color, strength);
            }
        `;

        // ðŸ”¹ --- Scene Setup --- ðŸ”¹
        let scene, camera, renderer, particles, animationLoop;
        const canvas = document.getElementById('particle-canvas');
        const clock = new THREE.Clock();
        
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0.0 },
                uState: { value: 0.0 }, // 0: running
                uRunProgress: { value: 0.0 },
            },
            vertexShader,
            fragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 8);

            renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const loader = new GLTFLoader();
            // This is a free CC-licensed model from Sketchfab, converted to GLB
            loader.load(
                'https://raw.githubusercontent.com/google/gemini-pro-demos/main/pixel-gallery/assets/rhino.glb',
                onModelLoad,
                undefined,
                (error) => {
                    console.error('Failed to load model, creating fallback geometry.', error);
                    createFallbackGeometry();
                }
            );

            window.addEventListener('resize', onWindowResize);
            document.getElementById('search-trigger').addEventListener('click', onSearchTrigger);
            
            animate();
        }

        function onModelLoad(gltf) {
            let rhinoGeometry;
            gltf.scene.traverse(child => {
                if (child.isMesh) {
                    rhinoGeometry = child.geometry;
                }
            });

            if (!rhinoGeometry) {
                console.error("No mesh found in the GLTF scene. Creating fallback.");
                createFallbackGeometry();
                return;
            }

            rhinoGeometry.computeVertexNormals();
            
            const positions = rhinoGeometry.attributes.position.array;
            const normals = rhinoGeometry.attributes.normal.array;
            const isHorn = new Float32Array(positions.length / 3);
            const isEye = new Float32Array(positions.length / 3);

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i+1];
                const z = positions[i+2];

                // Approximate horn vertices based on position (requires model inspection)
                if (y > 1.2 && z > 0.4) { 
                    isHorn[i/3] = 1.0;
                } else {
                    isHorn[i/3] = 0.0;
                }
                
                // Approximate eye vertices
                if (y > 1.0 && y < 1.2 && z > 0.35 && Math.abs(x) > 0.2) {
                    isEye[i/3] = 1.0;
                } else {
                    isEye[i/3] = 0.0;
                }
            }
            rhinoGeometry.setAttribute('aIsHorn', new THREE.BufferAttribute(isHorn, 1));
            rhinoGeometry.setAttribute('aIsEye', new THREE.BufferAttribute(isEye, 1));
            rhinoGeometry.setAttribute('aNormal', new THREE.BufferAttribute(normals, 3));

            setupSceneWithGeometry(rhinoGeometry);
        }

        function createFallbackGeometry() {
            const fallbackGeometry = new THREE.TorusKnotGeometry(1.5, 0.4, 300, 32);
            const isHorn = new Float32Array(fallbackGeometry.attributes.position.count).fill(0);
            const isEye = new Float32Array(fallbackGeometry.attributes.position.count).fill(0);
            fallbackGeometry.setAttribute('aIsHorn', new THREE.BufferAttribute(isHorn, 1));
            fallbackGeometry.setAttribute('aIsEye', new THREE.BufferAttribute(isEye, 1));
            fallbackGeometry.setAttribute('aNormal', fallbackGeometry.attributes.normal);
            setupSceneWithGeometry(fallbackGeometry);
        }

        function setupSceneWithGeometry(geometry) {
            particles = new THREE.Points(geometry, shaderMaterial);
            particles.position.set(15, -1, 0); // Start further off-screen
            particles.rotation.y = -Math.PI / 2;
            particles.scale.set(1.2, 1.2, 1.2);
            scene.add(particles);
            startCinematicLoop();
        }

        function startCinematicLoop() {
            if (animationLoop) animationLoop.kill();
            animationLoop = gsap.timeline({ repeat: -1 });

            const runPath = [
                { x: 5, z: 2, rotY: -Math.PI / 3 },
                { x: 0, z: 0, rotY: 0 },
            ];

            const exitPath = [
                { x: -5, z: -2, rotY: Math.PI / 3 },
                { x: -15, z: 0, rotY: Math.PI / 2 },
            ];

            animationLoop
                // Entry Run
                .add(() => { shaderMaterial.uniforms.uState.value = 0.0; })
                .to(particles.position, { 
                    x: runPath[0].x, z: runPath[0].z, duration: 2, ease: 'power1.inOut'
                })
                .to(particles.rotation, { y: runPath[0].rotY, duration: 2, ease: 'power1.inOut' }, "<")
                .to(particles.position, { 
                    x: runPath[1].x, z: runPath[1].z, duration: 2, ease: 'power1.inOut'
                })
                .to(particles.rotation, { y: runPath[1].rotY, duration: 2, ease: 'power1.inOut' }, "<")
                
                // Threat Display
                .add(() => { shaderMaterial.uniforms.uState.value = 1.0; })
                .to(camera.position, { x: 0, y: 1.2, z: 2.0, duration: 1.5, ease: 'power2.inOut' }, ">")
                .to({}, { duration: 2.5 }) // Hold for sensing

                // Exit Run
                .add(() => { shaderMaterial.uniforms.uState.value = 0.0; })
                .to(camera.position, { x: 0, y: 1, z: 8, duration: 2, ease: 'power2.inOut' })
                .to(particles.position, {
                    x: exitPath[0].x, z: exitPath[0].z, duration: 2, ease: 'power1.inOut'
                }, "<")
                .to(particles.rotation, { y: exitPath[0].rotY, duration: 2, ease: 'power1.inOut' }, "<")
                .to(particles.position, {
                    x: exitPath[1].x, z: exitPath[1].z, duration: 2, ease: 'power1.inOut'
                })
                .to(particles.rotation, { y: exitPath[1].rotY, duration: 2, ease: 'power1.inOut' }, "<")

                // Reset for next loop
                .add(() => { if(particles) particles.position.set(15, -1, 0); });
        }
        
        function onSearchTrigger() {
            if (animationLoop) animationLoop.kill();
            animationLoop = null;

            shaderMaterial.uniforms.uState.value = 2.0; // Set state to relaxing
            
            // Animate rhino to a calm, centered position
            gsap.to(particles.position, { x: 0, y: -1.2, z: 0, duration: 2, ease: 'power3.out' });
            gsap.to(particles.rotation, { x: 0.2, y: Math.PI / 12, z: 0, duration: 2, ease: 'power3.out' }); // Head down slightly
            gsap.to(camera.position, { x: 0, y: 1, z: 5, duration: 2, ease: 'power3.out' });
            gsap.to(camera.rotation, { x: 0, y: 0, z: 0, duration: 2, ease: 'power3.out' });
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            shaderMaterial.uniforms.uTime.value = elapsedTime;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
